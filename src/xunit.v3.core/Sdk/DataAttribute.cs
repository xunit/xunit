using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Threading.Tasks;
using Xunit.Internal;
using Xunit.v3;

namespace Xunit.Sdk;

/// <summary>
/// Abstract attribute which represents a data source for a data theory.
/// Data source providers derive from this attribute and implement GetData
/// to return the data for the theory.
/// </summary>
[DataDiscoverer(typeof(DataDiscoverer))]
[AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public abstract class DataAttribute : Attribute
{
	static readonly MethodInfo? tupleIndexerGetter;
	static readonly MethodInfo? tupleLengthGetter;
	static readonly Type? tupleType;

	static DataAttribute()
	{
		tupleType = Type.GetType("System.Runtime.CompilerServices.ITuple");
		if (tupleType is null)
			return;

		tupleIndexerGetter = tupleType.GetProperty("Item")?.GetMethod;
		tupleLengthGetter = tupleType.GetProperty("Length")?.GetMethod;
	}

	/// <summary>
	/// Gets a flag that indicates that the data row should only be run explicitly. If the value is not set,
	/// then it inherits its explicitness from the value of <see cref="FactAttribute.Explicit"/>.
	/// </summary>
	/// <remarks>
	/// Note: any data row which returns <see cref="ITheoryDataRow"/> with a non-<c>null</c>
	/// value for <see cref="ITheoryDataRow.Explicit"/> will use the explicit value from the data row
	/// and not the explicit value from the data attribute.
	/// </remarks>
	public bool Explicit
	{
		get => ExplicitWithoutDefaultValue ?? false;
		set => ExplicitWithoutDefaultValue = value;
	}

	/// <summary>
	/// Gets the value for <see cref="Explicit"/>, except that it keeps track of whether it has been set
	/// or not, and returns <c>null</c> if it hasn't been set.
	/// </summary>
	/// <remarks>
	/// Since attribute initializers cannot accept nullable boolean values, this secondary attribute value
	/// (that cannot be externally set) is required to keep track of whether <see cref="Explicit"/> has been
	/// set by the user or not. At reflection time, we can peer into the <see cref="CustomAttributeData"/>,
	/// but once the attribute instance has been created, this is the only way to know for sure.
	/// </remarks>
	protected bool? ExplicitWithoutDefaultValue { get; set; }

	/// <summary>
	/// Marks all test cases generated by this data source as skipped. If the value is <c>null</c>, then
	/// it inherits its skip reason from the value of <see cref="FactAttribute.Skip"/>.
	/// </summary>
	/// <remarks>
	/// Note: any data row which returns <see cref="ITheoryDataRow"/> with a non-<c>null</c>
	/// value for <see cref="ITheoryDataRow.Skip"/> will use the skip reason from the data row
	/// and not the skip reason from the data attribute.
	/// </remarks>
	public string? Skip { get; set; }

	/// <summary>
	/// Gets or sets the display name for the test (replacing the default behavior, which would be to
	/// use <see cref="FactAttribute.DisplayName"/>, or falling back to the default test display name
	/// based on <see cref="TestMethodDisplay"/> and <see cref="TestMethodDisplayOptions"/> in the
	/// configuration file).
	/// </summary>
	public string? TestDisplayName { get; set; }

	/// <summary>
	/// A value greater than zero marks the test as having a timeout, and gets or sets the
	/// timeout (in milliseconds). Setting a value here overrides any inherited value
	/// from the <see cref="TheoryAttribute"/>.
	/// </summary>
	/// <remarks>
	/// WARNING: Using this with parallelization turned on will result in undefined behavior.
	/// Timeout is only supported when parallelization is disabled, either globally or with
	/// a parallelization-disabled test collection.
	/// </remarks>
	public int Timeout
	{
		get => TimeoutWithoutDefaultValue ?? 0;
		set => TimeoutWithoutDefaultValue = value;
	}

	/// <summary>
	/// Gets the value for <see cref="Timeout"/>, except that it keeps track of whether it has been set
	/// or not, and returns <c>null</c> if it hasn't been set.
	/// </summary>
	/// <remarks>
	/// Since attribute initializers cannot accept nullable integer values, this secondary attribute value
	/// (that cannot be externally set) is required to keep track of whether <see cref="Timeout"/> has been
	/// set by the user or not. At reflection time, we can peer into the <see cref="CustomAttributeData"/>,
	/// but once the attribute instance has been created, this is the only way to know for sure.
	/// </remarks>
	protected int? TimeoutWithoutDefaultValue { get; set; }

	/// <summary>
	/// Gets or sets a set of traits for the associated data. The data is pushed as an array of
	/// string that are key/value pairs (f.e., <c>new[] { "key1", "value1", "key2", "value2" }</c>).
	/// </summary>
	/// <remarks>
	/// This is structured as an array because attribute initializers don't support dictionaries. Note:
	/// Setting an odd number of values will throw away the unmatched key at the end of the list. If you
	/// seem to be missing your a key/value pair or have misaligned keys and values, make sure you have
	/// an even number of strings alternating between keys and values.
	/// </remarks>
	public string[]? Traits { get; set; }

	/// <summary>
	/// Converts an item yielded by the data attribute to an <see cref="ITheoryDataRow"/>, for return
	/// from <see cref="GetData"/>. Items yielded will typically be <see cref="T:object[]"/>, <see cref="ITheoryDataRow"/>,
	/// or <see cref="T:System.Runtime.CompilerServices.ITuple"/>, but this override will allow derived
	/// derived attribute types to support additional data items. If the data item cannot be converted,
	/// this method will throw <see cref="ArgumentException"/>.
	/// </summary>
	/// <remarks>
	/// Any returned instance of <see cref="ITheoryDataRow"/> will be wrapped, and <see cref="ITheoryDataRow.Explicit"/>
	/// and/or <see cref="ITheoryDataRow.Skip"/> may be set with values from <see cref="ExplicitWithoutDefaultValue"/>
	/// and/or <see cref="Skip"/> if the data row did not provide overrides.
	/// </remarks>
	/// <param name="testMethod">The method that is being tested.</param>
	/// <param name="dataRow">An item yielded from the data member.</param>
	/// <returns>An <see cref="ITheoryDataRow"/> suitable for return from <see cref="GetData"/>.</returns>
	/// <exception cref="ArgumentException">Thrown when <paramref name="dataRow"/> does not point to a valid data
	/// row (must be compatible with <see cref="T:object[]"/> or <see cref="ITheoryDataRow"/>).</exception>
	protected virtual ITheoryDataRow ConvertDataRow(
		MethodInfo testMethod,
		object dataRow)
	{
		Guard.ArgumentNotNull(testMethod);
		Guard.ArgumentNotNull(dataRow);

		if (dataRow is ITheoryDataRow theoryDataRow)
		{
			var dataRowTraits = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

			if (theoryDataRow.Traits is not null)
				foreach (var kvp in theoryDataRow.Traits)
					dataRowTraits.GetOrAdd(kvp.Key).AddRange(kvp.Value);

			MergeTraitsInto(dataRowTraits);

			return new TheoryDataRow(theoryDataRow.GetData())
			{
				Explicit = theoryDataRow.Explicit ?? ExplicitWithoutDefaultValue,
				Skip = theoryDataRow.Skip ?? Skip,
				TestDisplayName = theoryDataRow.TestDisplayName ?? TestDisplayName,
				Timeout = theoryDataRow.Timeout ?? TimeoutWithoutDefaultValue,
				Traits = dataRowTraits,
			};
		}

		var traits = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
		MergeTraitsInto(traits);

		if (dataRow is object?[] array)
			return new TheoryDataRow(array)
			{
				Explicit = ExplicitWithoutDefaultValue,
				Skip = Skip,
				TestDisplayName = TestDisplayName,
				Timeout = TimeoutWithoutDefaultValue,
				Traits = traits,
			};

		if (tupleType is not null && tupleIndexerGetter is not null && tupleLengthGetter is not null)
		{
			if (tupleType.IsAssignableFrom(dataRow.GetType()))
			{
				var countObj = tupleLengthGetter.Invoke(dataRow, null);
				if (countObj is not null)
				{
					var count = (int)countObj;
					var data = new object?[count];
					for (var idx = 0; idx < count; ++idx)
						data[idx] = tupleIndexerGetter.Invoke(dataRow, new object[] { idx });

					return new TheoryDataRow(data)
					{
						Explicit = ExplicitWithoutDefaultValue,
						Skip = Skip,
						TestDisplayName = TestDisplayName,
						Timeout = TimeoutWithoutDefaultValue,
						Traits = traits,
					};
				}
			}
		}

		throw new ArgumentException(
			string.Format(
				CultureInfo.CurrentCulture,
				"Data row of type '{0}' is not an 'object?[]', 'Xunit.ITheoryDataRow' or 'System.Runtime.CompilerServices.ITuple'",
				dataRow.GetType().SafeName()
			),
			nameof(dataRow)
		);
	}

	/// <summary>
	/// Returns the data to be used to test the theory.
	/// </summary>
	/// <remarks>
	/// If you don't use <see cref="ConvertDataRow(MethodInfo, object)"/> to convert individual data rows
	/// into <see cref="ITheoryDataRow"/> instances, then make sure you are properly populating the theory
	/// data instance (with values from <see cref="ExplicitWithoutDefaultValue"/> and <see cref="Skip"/>).
	/// </remarks>
	/// <param name="testMethod">The method that is being tested</param>
	/// <param name="disposalTracker">The repository for tracking objects to be disposed of upon test completion</param>
	/// <returns>One or more rows of theory data. Each invocation of the test method
	/// is represented by a single instance of <see cref="ITheoryDataRow"/>.</returns>
	public abstract ValueTask<IReadOnlyCollection<ITheoryDataRow>?> GetData(MethodInfo testMethod, DisposalTracker disposalTracker);

	void MergeTraitsInto(Dictionary<string, List<string>> traits) =>
		TestIntrospectionHelper.MergeTraitsInto(traits, Traits);
}
